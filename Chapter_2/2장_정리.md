# 2장 리팩터링 원칙

- 리팩터링의 정의
  - 동작을 보존하는 단계들을 거쳐 코드를 수정하여 변화를 만들어내는 것. 언제나 코드가 정상 동작하기 때문에 언제든 멈출 수 있다.
  - 코드베이스를 정리하거나 구조를 바꾸는 작업 → 재구성(restructuring). 리팩터링은 재구성 중 특수한 한 형태이다.
  - 콜스택이 달라지거나 성능이 바뀔 수는 있지만 동작상으로는 동일한 결과를 만들어낸다.
- 두 개의 모자
  - 기능 추가를 할 때와 리팩터링할 때 각각의 역할에만 집중하도록 의식하라
- 리팩터링하는 이유
  - 소프트웨어 설계가 좋아진다.
    코드 구조가 무너지는 것을 막아줌
  - 소프트웨어를 이해하기 쉬워진다.
    사람도 이해하기 쉬운 코드를 짜는 것이 중요. 다름 아닌 나 자신이 코드 속 의도를 기억할 필요가 없다.
  - 버그를 쉽게 찾을 수 있다.
  - 프로그래밍 속도를 높일 수 있다.(”그 그래프”)
    기존의 코드를 최대한으로 활용할 수 있고, 기능 추가 시 이해해야 할 코드베이스 범위가 작아서 수월하게 추가/수정이 가능하다.
- 언제 리팩터링해야 할까?
  - 3의 법칙 → 비슷한 일을 세 번째 하게 될 때 한다
  - 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
    - 기능을 새로 추가하기 직전은 리팩하기 좋은 타이밍이다. 예로, 비슷한 작업의 중복을 막기위해 매개변수화 작업 등을 적용하라. 버그를 잡을 때도 마찬가지로 오류를 일으키는 코드가 여러 곳에 복제되어 퍼져있다면 우선 한 곳으로 합친 후 작업하라.
  - 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
    - 코드의 의도가 더 명확하게 드러나도록 수정하는 과정에서 코드를 깊은 수준까지 이해할 수 있게 된다.
  - 쓰레기 줍기 리팩터링
    - 작업 중 쓰레기 코드를 발견하면 싫지만 조금이나마 개선해두라. 캠핑처럼 처음 왔을 때보다 깔끔하게 정리하고 떠나라
  - 계획된 리팩터링과 수시로 하는 리팩터링
    - 리팩터링은 프로그래밍과 구분되는 활동이 아니다. 계획된 리팩터링도 좋지만 수시로 해라
  - 오래 걸리는 리팩터링
    - 대규모 리팩토링이 필요할 때도 팀 전체가 리팩터링에 매달리는 건 별로다. 그보다 몇 주에 걸쳐 조금씩 하는 편이 효과적일 때가 많다. (언제나 코드가 깨지지 않는다는 점 자랑)
  - 코드 리뷰에 리팩터링 활용하기
    - 리팩터링은 코드 리뷰에도 도움이 된다. pull request 방식에서는 효과적이지 않으나 페어 프로그래밍 시 도움이 됨(이해하기 쉬우니까)
  - 관리자에게는 뭐라고 말해야 할까?
    - 장기적으로 좋다는 논리로 설명하라. 못알아들으면 몰래 하라.
  - 리팩터링하지 말아야 할 때
    - 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.
- 코드 소유권
  - 모듈 외부에도 인터페이스 형태로 제공 중인 코드를 리팩토링 해야할 때도 있다. 코드 소유권을 느슨하게 함으로써 누구나 (심지어 이 코드를 가져다 쓰는 클라이언트 측까지도) 코드 관리에 참여하게 하면 유기적으로 수정하기 좋다.
- 브랜치
  - 마스터 브랜치에서 기능 추가용 브랜치를 따서 작업 후 마스터에 머지하는 방식은 작업 기간이 길어질 수록 통합이 어려워진다(또한 여러 기능 브랜치가 동시에 존재할 때). 따라서 매일 작업물을 마스터에 머지하는 방식을 제안함. 그러기 위해선 기능들을 잘게 쪼개야 하고, 각 기능들을 끌 수 있는 토글링이 적용되어야 할 것.
- 테스팅
  - 자가 테스트 코드를 갖추는 건 중요하다. 그래야 수시로 테스트 해보고 리팩토링 중 변경폭이 커지기 전에 오류를 잡아내어 원인을 빠르게 찾을 수 있다.
- 레거시 코드
  - 테스트 코드가 없는 레거시 코드를 명료하게 리팩터링하는 건 어렵다. 레거시 코드 활용 전략 → ‘프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다’.
- 데이터베이스
  - 데이터베이스 리팩터링도 핵심은 커다란 변경들을 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 db 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는데 있다. 여러 단계에 나눠 릴리즈 하는 편이 좋다.
- 리팩터링, 아키텍처, 애그니(YAGNI)
  - 리팩터링을 통해 코드가 작성된 뒤로도 아키텍처도 바꿀 수 있다. 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다. 유연성 메커니즘을 미리 심어두는 방식으로도 대응 가능하지만 보통의 경우 미리 유연성을 집어넣는 방식은 효과적이지 못할 때가 많다.
  - 리팩터링을 활용하면 추측하지 않고 필요 시마다 리팩터링과 함께 추가하면 된다. 이런 방식을 점진적 설계, YAGNI(you aren’t going to need it)등으로 부른다. YAGNI를 받아들인다고 해서 선제적인 아키텍처를 무시해도 된다는 뜻은 아니고, 나중에 문제를 더 깊이 이해하게된 시점에 처리하는 쪽이 낫다고 보는 관점을 말한다.
- 리팩터링과 소프트웨어 개발 프로세스
  - 지속적 통합, 자가 테스트코드, 리팩터링 등의 기법을 묶은 프로세스를 XP(익스트림 프로그래밍)이라 함. 최초의 애자일 소프트웨어 방법론 중 하나로 등장한 XP. 이름만 애자일인 프로젝트가 되지 않으려면 팀으로 개발하면서 리팩터링이 필수. 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다.
- 리팩터링과 성능
  - 리팩터링은 속도가 느려지게 하기도 하지만 성능을 튜닝하기도 쉽게 만든다.
  - 크라이슬러 종합 보상 시스템 어쩌구… 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야한다. 내가 잘못 알고 있었음을 깨닫게 된다
  - 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다. 그래서 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없는 셈이다.
  - 즉 의도적으로 성능 최적화에 돌입하기 전까지는 코드를 다루기 쉽게 만드는 데 집중한다. 그러다 성능 최적화 단계가 되면 필요한 부분을 튜닝하면 된다
- 리팩터링 자동화
  - IDE나 독립 도구에서 자동 리팩토링을 지원해주기도 한다. 자동 리팩토링을 지원하기 위해선 코드를 텍스트가 아닌 구문 트리로 다루는 편이 유리하고 이를 다시 텍스트로 전환해야하는 데 상당히 어렵다. 정적 타입 언어라면 안전하게 구현할 수 있는 리팩토링 수가 늘어난다. 멋진 툴이 많지만 직접 테스트를 충분히 하는 편이 바람직하다.
